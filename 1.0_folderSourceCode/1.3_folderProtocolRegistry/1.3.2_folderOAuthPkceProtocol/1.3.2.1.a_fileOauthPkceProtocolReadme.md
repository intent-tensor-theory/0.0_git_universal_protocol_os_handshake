# OAuth 2.0 with PKCE Protocol

> **Address:** 1.3.2  
> **Type:** Protocol Module  
> **Status:** Stable  
> **Version:** 1.0.0  
> **RFC:** RFC 7636 - Proof Key for Code Exchange

The recommended OAuth 2.0 flow for single-page applications (SPAs) and mobile apps. PKCE adds a layer of security that protects against authorization code interception attacks.

---

## Overview

OAuth 2.0 with PKCE (Proof Key for Code Exchange) is the **industry standard** for authenticating users in public clients like browser-based applications. It replaces the need for a client secret with a dynamically generated code verifier/challenge pair.

### Why PKCE?

- **No Client Secret Required**: SPAs can't securely store secrets
- **Code Interception Protection**: Even if code is stolen, it's useless without the verifier
- **Browser-Safe**: Works entirely in the browser
- **Standards Compliant**: RFC 7636 and OAuth 2.1 ready
- **Widely Supported**: All major providers support PKCE

---

## Quick Start

### 1. Configure Your OAuth Application

```typescript
const credentials = {
  clientId: 'your-client-id',
  authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenUrl: 'https://oauth2.googleapis.com/token',
  redirectUri: 'https://yourapp.com/auth/callback',
  scopes: 'openid email profile',
};
```

### 2. Start Authorization Flow

```typescript
import { OAuthPkceHandshakeExecutor } from './1.3.2.a_fileOauthPkceHandshakeExecutor';

const executor = new OAuthPkceHandshakeExecutor();
const authFlow = await executor.authenticate(credentials);

if (authFlow.type === 'redirect') {
  // Redirect user to OAuth provider
  window.location.href = authFlow.redirectUrl;
}
```

### 3. Handle Callback

```typescript
// In your callback handler (/auth/callback)
const params = new URLSearchParams(window.location.search);
const code = params.get('code');
const state = params.get('state');

// Exchange code for tokens
const tokens = await executor.performTokenExchange(credentials, code, codeVerifier);
```

### 4. Make Authenticated Requests

```typescript
const result = await executor.executeRequest({
  credentials: {
    ...credentials,
    accessToken: tokens.access_token,
  },
  url: 'https://www.googleapis.com/oauth2/v2/userinfo',
  method: 'GET',
  headers: {},
});
```

---

## How PKCE Works

```
┌──────────────────────────────────────────────────────────────────────┐
│                          PKCE Flow                                    │
├──────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  1. Generate PKCE Values                                             │
│     ├─ code_verifier = random_string(43 chars)                      │
│     └─ code_challenge = BASE64URL(SHA256(code_verifier))            │
│                                                                       │
│  2. Authorization Request                                            │
│     GET /authorize?                                                  │
│       client_id=xxx                                                  │
│       &redirect_uri=xxx                                              │
│       &code_challenge=xxx      ← Send challenge                     │
│       &code_challenge_method=S256                                   │
│                                                                       │
│  3. User Authenticates                                               │
│     └─ Provider stores code_challenge                               │
│                                                                       │
│  4. Authorization Callback                                           │
│     GET /callback?code=xxx&state=xxx                                │
│                                                                       │
│  5. Token Exchange                                                   │
│     POST /token                                                      │
│       grant_type=authorization_code                                 │
│       &code=xxx                                                      │
│       &code_verifier=xxx       ← Send original verifier             │
│                                                                       │
│  6. Provider Verifies                                                │
│     SHA256(code_verifier) == stored_code_challenge                  │
│                                                                       │
│  7. Tokens Issued ✓                                                  │
│                                                                       │
└──────────────────────────────────────────────────────────────────────┘
```

---

## Supported Providers

Protocol OS includes presets for popular OAuth providers:

| Provider | Authorization URL | Scopes |
|----------|-------------------|--------|
| **Google** | accounts.google.com | openid, email, profile, drive, calendar |
| **Microsoft** | login.microsoftonline.com | openid, User.Read, Mail.Read |
| **GitHub** | github.com | read:user, user:email, repo |
| **Slack** | slack.com | openid, channels:read, chat:write |
| **Auth0** | {domain}.auth0.com | openid, offline_access |
| **Okta** | {domain}.okta.com | openid, profile, email |

### Using Provider Presets

```typescript
import { OAUTH_PROVIDER_PRESETS } from './1.3.2.b_fileOauthPkceCredentialFormFields';

const googlePreset = OAUTH_PROVIDER_PRESETS.find(p => p.id === 'google');

const credentials = {
  clientId: 'your-client-id',
  redirectUri: 'https://yourapp.com/callback',
  authorizationUrl: googlePreset.authorizationUrl,
  tokenUrl: googlePreset.tokenUrl,
  scopes: googlePreset.defaultScopes.join(' '),
};
```

---

## PKCE Utilities

### Generate Code Verifier & Challenge

```typescript
import { 
  generateCodeVerifier, 
  generateCodeChallenge,
  generatePkceValues 
} from './1.3.2.d_fileOauthPkceCodeChallengeGenerator';

// Method 1: Separate calls
const verifier = generateCodeVerifier();
const challenge = await generateCodeChallenge(verifier);

// Method 2: Generate both at once
const pkce = await generatePkceValues();
console.log(pkce.verifier);   // Keep secret
console.log(pkce.challenge);  // Send to /authorize
console.log(pkce.method);     // "S256"
```

### State Parameter for CSRF Protection

```typescript
import { generateState, validateState } from './1.3.2.d_fileOauthPkceCodeChallengeGenerator';

// Before redirect
const state = generateState({ returnTo: '/dashboard' });
sessionStorage.setItem('oauth_state', state);

// After callback
const receivedState = params.get('state');
const storedState = sessionStorage.getItem('oauth_state');

const validation = validateState(receivedState, storedState);
if (!validation.valid) {
  throw new Error(validation.error);
}
```

### PKCE State Manager

```typescript
import { PkceStateManager } from './1.3.2.d_fileOauthPkceCodeChallengeGenerator';

const pkceManager = new PkceStateManager();

// Start flow - stores verifier in sessionStorage
const { verifier, challenge, state } = await pkceManager.initializeFlow({
  returnTo: window.location.pathname
});

// Build authorization URL with challenge
const authUrl = `${authorizationUrl}?...&code_challenge=${challenge}&state=${state}`;

// After callback - retrieves and clears verifier
const result = pkceManager.completeFlow(receivedState);
if (result.success) {
  // Exchange code with result.verifier
}
```

---

## Token Management

### Token Refresh

```typescript
const refreshResult = await executor.refreshTokens(credentials);

if (refreshResult.success) {
  credentials.accessToken = refreshResult.accessToken;
  credentials.refreshToken = refreshResult.refreshToken;  // May be rotated
  credentials.tokenExpiresAt = refreshResult.expiresAt;
}
```

### Token Revocation

```typescript
const revokeResult = await executor.revokeTokens(credentials);
if (revokeResult.success) {
  // Clear local tokens
}
```

### Check Token Expiration

```typescript
if (executor.isTokenExpired(credentials)) {
  // Refresh or re-authenticate
}

const expiresAt = executor.getTokenExpirationTime(credentials);
console.log(`Token expires at: ${expiresAt}`);
```

---

## Configuration Reference

### Required Fields

| Field | Description | Example |
|-------|-------------|---------|
| `clientId` | OAuth application client ID | `spa_client_123` |
| `authorizationUrl` | Provider's authorize endpoint | `https://auth.example.com/authorize` |
| `tokenUrl` | Provider's token endpoint | `https://auth.example.com/token` |
| `redirectUri` | Your callback URL | `https://yourapp.com/callback` |
| `scopes` | Requested permissions | `openid email profile` |

### Optional Fields

| Field | Description | Default |
|-------|-------------|---------|
| `userInfoUrl` | User info endpoint | - |
| `revocationUrl` | Token revocation endpoint | - |
| `audience` | API audience (Auth0, etc.) | - |
| `additionalAuthParams` | Extra auth params | `{}` |

---

## Security Best Practices

### Token Storage

```typescript
// ✅ GOOD: Store in memory
class TokenStore {
  private token: string | null = null;
  
  set(token: string) { this.token = token; }
  get() { return this.token; }
  clear() { this.token = null; }
}

// ❌ BAD: Never use localStorage for tokens
localStorage.setItem('token', accessToken); // XSS vulnerable!
```

### State Validation

```typescript
// ✅ ALWAYS validate state parameter
if (receivedState !== storedState) {
  throw new Error('CSRF attack detected');
}

// ✅ Check state expiration
const stateData = parseState(state);
if (Date.now() - stateData.ts > 10 * 60 * 1000) {
  throw new Error('State expired');
}
```

### URL Handling

```typescript
// ✅ Clear sensitive params from URL after processing
window.history.replaceState({}, '', window.location.pathname);
```

---

## Error Handling

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `invalid_grant` | Code expired or already used | Restart auth flow |
| `invalid_client` | Wrong client ID | Check client ID |
| `invalid_scope` | Unsupported scope | Check provider docs |
| `access_denied` | User denied consent | Handle gracefully |
| `state_mismatch` | CSRF protection triggered | Restart auth flow |

### Error Handling Example

```typescript
try {
  const result = await executor.handleCallback(params);
  
  if (result.type === 'error') {
    switch (result.error) {
      case 'access_denied':
        showMessage('Authorization was denied');
        break;
      case 'state_mismatch':
        showMessage('Security check failed. Please try again.');
        break;
      default:
        showMessage(`Authentication failed: ${result.error}`);
    }
  }
} catch (error) {
  showMessage('An unexpected error occurred');
}
```

---

## Provider-Specific Notes

### Google

```typescript
// Required for refresh tokens
additionalAuthParams: {
  access_type: 'offline',
  prompt: 'consent'
}
```

### Microsoft

```typescript
// Use specific tenant for organization-only apps
authorizationUrl: 'https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize'

// Common scopes
scopes: 'openid email profile User.Read offline_access'
```

### Auth0

```typescript
// Required for API access
additionalAuthParams: {
  audience: 'https://api.yourapp.com'
}
```

---

## Troubleshooting

### "Invalid code_challenge"

- Ensure you're using S256 method (not plain)
- Check Base64-URL encoding (no `+`, `/`, or `=`)
- Verify the challenge is derived from the verifier

### "State mismatch"

- Check sessionStorage isn't being cleared
- Ensure you're on the same domain
- Verify state was stored before redirect

### "Refresh token not returned"

For Google:
- Add `access_type=offline` to auth params
- Add `prompt=consent` on first auth

For others:
- Add `offline_access` to scopes

### "Token expired immediately"

- Check your system clock is correct
- Some providers return short-lived tokens (1 hour)
- Implement proactive refresh before expiration

---

## Files in This Module

| File | Purpose |
|------|---------|
| `1.3.2.a_fileOauthPkceHandshakeExecutor.ts` | Core OAuth PKCE implementation |
| `1.3.2.b_fileOauthPkceCredentialFormFields.tsx` | React UI component |
| `1.3.2.c_fileOauthPkceWhitepaperDocumentation.ts` | Technical specification |
| `1.3.2.d_fileOauthPkceCodeChallengeGenerator.ts` | PKCE crypto utilities |
| `1.3.2.1.a_fileOauthPkceProtocolReadme.md` | This documentation |

---

## Related Resources

- [RFC 7636 - PKCE](https://datatracker.ietf.org/doc/html/rfc7636)
- [OAuth 2.0 for Browser-Based Apps](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)
- [Protocol Module Interface](../1.3.b_fileProtocolHandshakeModuleInterface.ts)

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2024-12-03 | Initial release with PKCE support |

---

*Protocol OS - Configure once, connect anywhere.*
