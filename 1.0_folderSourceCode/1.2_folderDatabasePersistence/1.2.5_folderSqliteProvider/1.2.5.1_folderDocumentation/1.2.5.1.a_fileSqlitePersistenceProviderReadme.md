# SQLite Persistence Provider

**Address:** `1.2.5`  
**Type:** SQLite File Database  
**Setup Required:** None (auto-created)

---

## Overview

SQLite provider stores data in a single file (or in-memory), making it perfect for portable, embedded, and offline-first applications. Zero configuration required.

## Features

| Feature | Supported |
|---------|-----------|
| Zero Configuration | ✅ |
| Single File Storage | ✅ |
| ACID Transactions | ✅ |
| Full SQL Support | ✅ |
| Offline Support | ✅ |
| Portable Database | ✅ |
| Multi-User | ⚠️ (limited) |
| Browser Direct | ⚠️ (via sql.js) |

## Setup

### 1. Install Dependencies

```bash
npm install better-sqlite3
```

For TypeScript:
```bash
npm install -D @types/better-sqlite3
```

### 2. Configure Environment

```env
# .env

# File-based database (will be created automatically)
VITE_SQLITE_PATH=./data/protocol-os.db

# Or use in-memory (data lost on restart)
VITE_SQLITE_PATH=:memory:

# Optional
VITE_SQLITE_MODE=readwrite
VITE_DB_DEBUG=true
```

### 3. Switch Provider

```typescript
// In 1.2.c_fileActiveDatabaseProviderToggle.ts
const ACTIVE_PROVIDER: DatabaseProviderType = 'sqlite';
```

That's it! The schema is automatically created on first run.

## Database Modes

| Mode | Description |
|------|-------------|
| `:memory:` | In-memory database (fastest, data lost on close) |
| `./path/to/db.sqlite` | File-based (persistent, portable) |
| `readonly` | Open existing file read-only |

## Storage Location

File-based databases are stored relative to your project root:

```
project/
├── data/
│   └── protocol-os.db      ← SQLite database
│   └── protocol-os.db-wal  ← WAL journal (if WAL mode enabled)
│   └── protocol-os.db-shm  ← Shared memory file
├── src/
└── ...
```

## Schema Overview

SQLite uses TEXT for UUIDs and JSON:

```sql
platforms
├── id (TEXT, PK)
├── serial (TEXT, UNIQUE)
├── name (TEXT)
├── url (TEXT)
├── contributors (TEXT, JSON)
├── is_master (INTEGER, 0/1)
├── is_archived (INTEGER, 0/1)
├── created_at (TEXT, ISO8601)
└── updated_at (TEXT, ISO8601)
```

**Note:** SQLite doesn't have native BOOLEAN or JSONB types:
- Booleans stored as INTEGER (0/1)
- JSON stored as TEXT (automatically serialized/parsed)

## WAL Mode

Write-Ahead Logging (WAL) is enabled by default for better concurrency:

```typescript
db.pragma('journal_mode = WAL');
```

Benefits:
- Readers don't block writers
- Writers don't block readers
- Better crash recovery
- Improved performance for writes

Disable if needed:
```env
VITE_SQLITE_WAL_MODE=false
```

## Performance Tips

### Connection Reuse

SQLite connections are fast to create, but reusing is still better:

```typescript
// ✅ Good: Reuse the provider
const db = getActiveProvider();
await db.createPlatform(platform1);
await db.createPlatform(platform2);

// ❌ Bad: Don't reinitialize unnecessarily
await initializeDatabase();
await initializeDatabase();
```

### Batch Operations

Use transactions for multiple operations:

```typescript
const txn = await db.beginTransaction();

for (const platform of platforms) {
  txn.addOperation({
    type: 'create',
    collection: 'platforms',
    data: platform,
  });
}

await txn.commit(); // All-or-nothing
```

### Vacuum Regularly

Reclaim space after deletes:

```typescript
import { optimizeDatabase } from '@database/sqlite';

// Run periodically or after large deletions
optimizeDatabase(db);
```

## Browser Support

For browser-based applications, use **sql.js** (SQLite compiled to WASM):

```bash
npm install sql.js
```

The provider auto-detects the environment and uses the appropriate driver.

**Limitations in browser:**
- Larger bundle size (~1MB)
- Slower than native
- Must manually save to IndexedDB or localStorage

## File Portability

SQLite databases are single-file and cross-platform:

```bash
# Copy database to another machine
scp ./data/protocol-os.db user@server:~/data/

# Or include in your Docker image
COPY ./data/protocol-os.db /app/data/
```

## Backup & Restore

### Backup

```typescript
import { backupDatabase } from '@database/sqlite';

await backupDatabase(db, './backups/protocol-os-backup.db');
```

Or manually:
```bash
cp ./data/protocol-os.db ./backups/protocol-os-$(date +%Y%m%d).db
```

### Restore

Simply replace the database file:
```bash
cp ./backups/protocol-os-backup.db ./data/protocol-os.db
```

## Integrity Check

Verify database integrity:

```typescript
import { checkDatabaseIntegrity } from '@database/sqlite';

const { ok, result } = checkDatabaseIntegrity(db);
if (!ok) {
  console.error('Database corruption detected:', result);
}
```

## Database Size

Monitor database size:

```typescript
import { getDatabaseSize } from '@database/sqlite';

const { pageSize, pageCount, totalBytes } = getDatabaseSize(db);
console.log(`Database size: ${(totalBytes / 1024 / 1024).toFixed(2)} MB`);
```

## Concurrency

SQLite has limited concurrent write support:

| Operation | Concurrent Support |
|-----------|-------------------|
| Multiple readers | ✅ Unlimited |
| Single writer | ✅ Yes |
| Multiple writers | ⚠️ Serialized (one at a time) |

For high-write workloads, consider:
- PostgreSQL for server deployments
- Supabase for cloud deployments

## Troubleshooting

### "database is locked"

Multiple processes trying to write simultaneously:
- Ensure only one process writes at a time
- Enable WAL mode
- Increase timeout: `timeout: 10000`

### "SQLITE_CORRUPT"

Database file corrupted:
1. Check disk space
2. Restore from backup
3. Run `PRAGMA integrity_check`

### "no such table"

Schema not initialized:
- The provider auto-creates tables on `initialize()`
- Check if `initialize()` was called

### "disk I/O error"

- Check disk space
- Check file permissions
- Ensure path exists

## Comparison

| Feature | SQLite | localStorage | PostgreSQL |
|---------|--------|--------------|------------|
| Setup | None | None | Required |
| Portability | High | Browser only | Low |
| Transactions | Yes | No | Yes |
| Concurrent writes | Limited | N/A | High |
| Max size | ~140TB | 5MB | Unlimited |
| SQL support | Full | None | Full |

---

## When to Use

✅ **Recommended for:**
- Desktop applications (Electron, Tauri)
- CLI tools
- Development and testing
- Offline-first applications
- Single-user scenarios
- Edge deployments

❌ **Not recommended for:**
- High-concurrency web servers
- Multi-user real-time apps
- Distributed systems
- When you need cloud sync
